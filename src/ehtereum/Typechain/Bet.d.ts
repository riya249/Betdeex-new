/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction
} from "ethers";
import {
  Contract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides
} from "@ethersproject/contracts";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";

interface BetInterface extends ethers.utils.Interface {
  functions: {
    "KYC(address)": FunctionFragment;
    "betBalanceInExaEs(address)": FunctionFragment;
    "bettorBetAmountInExaEsByChoice(address,uint256)": FunctionFragment;
    "bettorHasClaimed(address)": FunctionFragment;
    "category()": FunctionFragment;
    "description()": FunctionFragment;
    "downVotes()": FunctionFragment;
    "downvote()": FunctionFragment;
    "endBet(uint8)": FunctionFragment;
    "endTimestamp()": FunctionFragment;
    "endedBy()": FunctionFragment;
    "enterBet(uint8,uint256)": FunctionFragment;
    "finalResult()": FunctionFragment;
    "getNumberOfChoiceBettors(uint256)": FunctionFragment;
    "initialize(address,string,uint8,uint8,uint256,uint256,bool,uint256)": FunctionFragment;
    "isBetValid(address)": FunctionFragment;
    "isDrawPossible()": FunctionFragment;
    "minimumBetInExaEs()": FunctionFragment;
    "pauseTimestamp()": FunctionFragment;
    "prizePercentPerThousand()": FunctionFragment;
    "seeWinnerPrize(address)": FunctionFragment;
    "setKYC(address)": FunctionFragment;
    "subCategory()": FunctionFragment;
    "totalBetTokensInExaEsByChoice(uint256)": FunctionFragment;
    "totalContractBalance()": FunctionFragment;
    "totalPrize()": FunctionFragment;
    "upVotes()": FunctionFragment;
    "upvote()": FunctionFragment;
    "withdrawPrize(address)": FunctionFragment;
  };

  encodeFunctionData(functionFragment: "KYC", values: [string]): string;
  encodeFunctionData(
    functionFragment: "betBalanceInExaEs",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "bettorBetAmountInExaEsByChoice",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "bettorHasClaimed",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "category", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "description",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "downVotes", values?: undefined): string;
  encodeFunctionData(functionFragment: "downvote", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "endBet",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "endTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "endedBy", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "enterBet",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "finalResult",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getNumberOfChoiceBettors",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      boolean,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(functionFragment: "isBetValid", values: [string]): string;
  encodeFunctionData(
    functionFragment: "isDrawPossible",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "minimumBetInExaEs",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "pauseTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "prizePercentPerThousand",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "seeWinnerPrize",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "setKYC", values: [string]): string;
  encodeFunctionData(
    functionFragment: "subCategory",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalBetTokensInExaEsByChoice",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "totalContractBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalPrize",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "upVotes", values?: undefined): string;
  encodeFunctionData(functionFragment: "upvote", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "withdrawPrize",
    values: [string]
  ): string;

  decodeFunctionResult(functionFragment: "KYC", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "betBalanceInExaEs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bettorBetAmountInExaEsByChoice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bettorHasClaimed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "category", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "description",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "downVotes", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "downvote", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "endBet", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "endTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "endedBy", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "enterBet", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "finalResult",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNumberOfChoiceBettors",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isBetValid", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isDrawPossible",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minimumBetInExaEs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "pauseTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "prizePercentPerThousand",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "seeWinnerPrize",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setKYC", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "subCategory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalBetTokensInExaEsByChoice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalContractBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "totalPrize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "upVotes", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "upvote", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawPrize",
    data: BytesLike
  ): Result;

  events: {
    "EndBetContract(address,address,uint8,uint256)": EventFragment;
    "NewBetting(address,address,uint8,uint256)": EventFragment;
    "TransferES(address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "EndBetContract"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewBetting"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferES"): EventFragment;
}

export class Bet extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: BetInterface;

  functions: {
    KYC(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "KYC(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    betBalanceInExaEs(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "betBalanceInExaEs(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    bettorBetAmountInExaEsByChoice(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "bettorBetAmountInExaEsByChoice(address,uint256)"(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    bettorHasClaimed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "bettorHasClaimed(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    category(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    "category()"(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    description(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "description()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    downVotes(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "downVotes()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    downvote(overrides?: Overrides): Promise<ContractTransaction>;

    "downvote()"(overrides?: Overrides): Promise<ContractTransaction>;

    /**
     * this function is used by manager to load correct answer
     * @param _choice is the correct choice
     */
    endBet(
      _choice: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * this function is used by manager to load correct answer
     * @param _choice is the correct choice
     */
    "endBet(uint8)"(
      _choice: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    endTimestamp(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "endTimestamp()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    endedBy(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "endedBy()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * this function is used to place a bet on available choice
     * @param _betTokensInExaEs is amount of bet
     * @param _choice should be 0, 1, 2; no => 0, yes => 1, draw => 2
     */
    enterBet(
      _choice: BigNumberish,
      _betTokensInExaEs: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    /**
     * this function is used to place a bet on available choice
     * @param _betTokensInExaEs is amount of bet
     * @param _choice should be 0, 1, 2; no => 0, yes => 1, draw => 2
     */
    "enterBet(uint8,uint256)"(
      _choice: BigNumberish,
      _betTokensInExaEs: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    finalResult(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    "finalResult()"(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    getNumberOfChoiceBettors(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "getNumberOfChoiceBettors(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * this sets up Bet contract
     * @param _category is the broad category for example Sports. Purpose of this is only to filter bets and show in UI, hence the name of the category is not stored in smart contract and category is repressented by a number (0, 1, 2, 3...)
     * @param _description is the question of Bet in plain English, bettors have to understand the bet description and later choose to bet on yes no or draw according to their preference
     * @param _isDrawPossible is functionality for allowing a draw option
     * @param _minimumBetInExaEs is the least amount of ExaES that can be betted, any bet participant (bettor) will have to bet this amount or higher. Betting higher amount gives more share of winning amount
     * @param _pauseTimestamp Bet will be open for betting until this timestamp, after this timestamp, any user will not be able to place bet. and manager can only end bet after this time
     * @param _prizePercentPerThousand is a form of representation of platform fee. It is a number less than or equal to 1000. For eg 2% is to be collected as platform fee then this value would be 980. If 0.2% then 998.
     * @param _subCategory is a specific category for example Football. Each category will have sub categories represented by a number (0, 1, 2, 3...)
     */
    initialize(
      _owner1: string,
      _description: string,
      _category: BigNumberish,
      _subCategory: BigNumberish,
      _minimumBetInExaEs: BigNumberish,
      _prizePercentPerThousand: BigNumberish,
      _isDrawPossible: boolean,
      _pauseTimestamp: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * this sets up Bet contract
     * @param _category is the broad category for example Sports. Purpose of this is only to filter bets and show in UI, hence the name of the category is not stored in smart contract and category is repressented by a number (0, 1, 2, 3...)
     * @param _description is the question of Bet in plain English, bettors have to understand the bet description and later choose to bet on yes no or draw according to their preference
     * @param _isDrawPossible is functionality for allowing a draw option
     * @param _minimumBetInExaEs is the least amount of ExaES that can be betted, any bet participant (bettor) will have to bet this amount or higher. Betting higher amount gives more share of winning amount
     * @param _pauseTimestamp Bet will be open for betting until this timestamp, after this timestamp, any user will not be able to place bet. and manager can only end bet after this time
     * @param _prizePercentPerThousand is a form of representation of platform fee. It is a number less than or equal to 1000. For eg 2% is to be collected as platform fee then this value would be 980. If 0.2% then 998.
     * @param _subCategory is a specific category for example Football. Each category will have sub categories represented by a number (0, 1, 2, 3...)
     */
    "initialize(address,string,uint8,uint8,uint256,uint256,bool,uint256)"(
      _owner1: string,
      _description: string,
      _category: BigNumberish,
      _subCategory: BigNumberish,
      _minimumBetInExaEs: BigNumberish,
      _prizePercentPerThousand: BigNumberish,
      _isDrawPossible: boolean,
      _pauseTimestamp: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    isBetValid(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "isBetValid(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    isDrawPossible(
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "isDrawPossible()"(
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    minimumBetInExaEs(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "minimumBetInExaEs()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    pauseTimestamp(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "pauseTimestamp()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    prizePercentPerThousand(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "prizePercentPerThousand()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * this function can be called by anyone to see how much winners are getting
     * @param _bettorAddress is address whose prize we want to see
     */
    seeWinnerPrize(
      _bettorAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * this function can be called by anyone to see how much winners are getting
     * @param _bettorAddress is address whose prize we want to see
     */
    "seeWinnerPrize(address)"(
      _bettorAddress: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    setKYC(user: string, overrides?: Overrides): Promise<ContractTransaction>;

    "setKYC(address)"(
      user: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    subCategory(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    "subCategory()"(
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    totalBetTokensInExaEsByChoice(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "totalBetTokensInExaEsByChoice(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * this function gives amount of ExaEs that is total betted on this bet
     */
    totalContractBalance(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * this function gives amount of ExaEs that is total betted on this bet
     */
    "totalContractBalance()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    totalPrize(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "totalPrize()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    upVotes(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "upVotes()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    upvote(overrides?: Overrides): Promise<ContractTransaction>;

    "upvote()"(overrides?: Overrides): Promise<ContractTransaction>;

    /**
     * this function will be called after bet ends and winner bettors can withdraw their prize share
     */
    withdrawPrize(
      _bettorAddress: string,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    /**
     * this function will be called after bet ends and winner bettors can withdraw their prize share
     */
    "withdrawPrize(address)"(
      _bettorAddress: string,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;
  };

  KYC(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  "KYC(address)"(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  betBalanceInExaEs(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "betBalanceInExaEs(address)"(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  bettorBetAmountInExaEsByChoice(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "bettorBetAmountInExaEsByChoice(address,uint256)"(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  bettorHasClaimed(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  "bettorHasClaimed(address)"(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  category(overrides?: CallOverrides): Promise<number>;

  "category()"(overrides?: CallOverrides): Promise<number>;

  description(overrides?: CallOverrides): Promise<string>;

  "description()"(overrides?: CallOverrides): Promise<string>;

  downVotes(overrides?: CallOverrides): Promise<BigNumber>;

  "downVotes()"(overrides?: CallOverrides): Promise<BigNumber>;

  downvote(overrides?: Overrides): Promise<ContractTransaction>;

  "downvote()"(overrides?: Overrides): Promise<ContractTransaction>;

  /**
   * this function is used by manager to load correct answer
   * @param _choice is the correct choice
   */
  endBet(
    _choice: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * this function is used by manager to load correct answer
   * @param _choice is the correct choice
   */
  "endBet(uint8)"(
    _choice: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  endTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

  "endTimestamp()"(overrides?: CallOverrides): Promise<BigNumber>;

  endedBy(overrides?: CallOverrides): Promise<string>;

  "endedBy()"(overrides?: CallOverrides): Promise<string>;

  /**
   * this function is used to place a bet on available choice
   * @param _betTokensInExaEs is amount of bet
   * @param _choice should be 0, 1, 2; no => 0, yes => 1, draw => 2
   */
  enterBet(
    _choice: BigNumberish,
    _betTokensInExaEs: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  /**
   * this function is used to place a bet on available choice
   * @param _betTokensInExaEs is amount of bet
   * @param _choice should be 0, 1, 2; no => 0, yes => 1, draw => 2
   */
  "enterBet(uint8,uint256)"(
    _choice: BigNumberish,
    _betTokensInExaEs: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  finalResult(overrides?: CallOverrides): Promise<number>;

  "finalResult()"(overrides?: CallOverrides): Promise<number>;

  getNumberOfChoiceBettors(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "getNumberOfChoiceBettors(uint256)"(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * this sets up Bet contract
   * @param _category is the broad category for example Sports. Purpose of this is only to filter bets and show in UI, hence the name of the category is not stored in smart contract and category is repressented by a number (0, 1, 2, 3...)
   * @param _description is the question of Bet in plain English, bettors have to understand the bet description and later choose to bet on yes no or draw according to their preference
   * @param _isDrawPossible is functionality for allowing a draw option
   * @param _minimumBetInExaEs is the least amount of ExaES that can be betted, any bet participant (bettor) will have to bet this amount or higher. Betting higher amount gives more share of winning amount
   * @param _pauseTimestamp Bet will be open for betting until this timestamp, after this timestamp, any user will not be able to place bet. and manager can only end bet after this time
   * @param _prizePercentPerThousand is a form of representation of platform fee. It is a number less than or equal to 1000. For eg 2% is to be collected as platform fee then this value would be 980. If 0.2% then 998.
   * @param _subCategory is a specific category for example Football. Each category will have sub categories represented by a number (0, 1, 2, 3...)
   */
  initialize(
    _owner1: string,
    _description: string,
    _category: BigNumberish,
    _subCategory: BigNumberish,
    _minimumBetInExaEs: BigNumberish,
    _prizePercentPerThousand: BigNumberish,
    _isDrawPossible: boolean,
    _pauseTimestamp: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * this sets up Bet contract
   * @param _category is the broad category for example Sports. Purpose of this is only to filter bets and show in UI, hence the name of the category is not stored in smart contract and category is repressented by a number (0, 1, 2, 3...)
   * @param _description is the question of Bet in plain English, bettors have to understand the bet description and later choose to bet on yes no or draw according to their preference
   * @param _isDrawPossible is functionality for allowing a draw option
   * @param _minimumBetInExaEs is the least amount of ExaES that can be betted, any bet participant (bettor) will have to bet this amount or higher. Betting higher amount gives more share of winning amount
   * @param _pauseTimestamp Bet will be open for betting until this timestamp, after this timestamp, any user will not be able to place bet. and manager can only end bet after this time
   * @param _prizePercentPerThousand is a form of representation of platform fee. It is a number less than or equal to 1000. For eg 2% is to be collected as platform fee then this value would be 980. If 0.2% then 998.
   * @param _subCategory is a specific category for example Football. Each category will have sub categories represented by a number (0, 1, 2, 3...)
   */
  "initialize(address,string,uint8,uint8,uint256,uint256,bool,uint256)"(
    _owner1: string,
    _description: string,
    _category: BigNumberish,
    _subCategory: BigNumberish,
    _minimumBetInExaEs: BigNumberish,
    _prizePercentPerThousand: BigNumberish,
    _isDrawPossible: boolean,
    _pauseTimestamp: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  isBetValid(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  "isBetValid(address)"(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isDrawPossible(overrides?: CallOverrides): Promise<boolean>;

  "isDrawPossible()"(overrides?: CallOverrides): Promise<boolean>;

  minimumBetInExaEs(overrides?: CallOverrides): Promise<BigNumber>;

  "minimumBetInExaEs()"(overrides?: CallOverrides): Promise<BigNumber>;

  pauseTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

  "pauseTimestamp()"(overrides?: CallOverrides): Promise<BigNumber>;

  prizePercentPerThousand(overrides?: CallOverrides): Promise<BigNumber>;

  "prizePercentPerThousand()"(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * this function can be called by anyone to see how much winners are getting
   * @param _bettorAddress is address whose prize we want to see
   */
  seeWinnerPrize(
    _bettorAddress: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * this function can be called by anyone to see how much winners are getting
   * @param _bettorAddress is address whose prize we want to see
   */
  "seeWinnerPrize(address)"(
    _bettorAddress: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  setKYC(user: string, overrides?: Overrides): Promise<ContractTransaction>;

  "setKYC(address)"(
    user: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  subCategory(overrides?: CallOverrides): Promise<number>;

  "subCategory()"(overrides?: CallOverrides): Promise<number>;

  totalBetTokensInExaEsByChoice(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "totalBetTokensInExaEsByChoice(uint256)"(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * this function gives amount of ExaEs that is total betted on this bet
   */
  totalContractBalance(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * this function gives amount of ExaEs that is total betted on this bet
   */
  "totalContractBalance()"(overrides?: CallOverrides): Promise<BigNumber>;

  totalPrize(overrides?: CallOverrides): Promise<BigNumber>;

  "totalPrize()"(overrides?: CallOverrides): Promise<BigNumber>;

  upVotes(overrides?: CallOverrides): Promise<BigNumber>;

  "upVotes()"(overrides?: CallOverrides): Promise<BigNumber>;

  upvote(overrides?: Overrides): Promise<ContractTransaction>;

  "upvote()"(overrides?: Overrides): Promise<ContractTransaction>;

  /**
   * this function will be called after bet ends and winner bettors can withdraw their prize share
   */
  withdrawPrize(
    _bettorAddress: string,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  /**
   * this function will be called after bet ends and winner bettors can withdraw their prize share
   */
  "withdrawPrize(address)"(
    _bettorAddress: string,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  callStatic: {
    KYC(arg0: string, overrides?: CallOverrides): Promise<boolean>;

    "KYC(address)"(arg0: string, overrides?: CallOverrides): Promise<boolean>;

    betBalanceInExaEs(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "betBalanceInExaEs(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    bettorBetAmountInExaEsByChoice(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "bettorBetAmountInExaEsByChoice(address,uint256)"(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    bettorHasClaimed(arg0: string, overrides?: CallOverrides): Promise<boolean>;

    "bettorHasClaimed(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    category(overrides?: CallOverrides): Promise<number>;

    "category()"(overrides?: CallOverrides): Promise<number>;

    description(overrides?: CallOverrides): Promise<string>;

    "description()"(overrides?: CallOverrides): Promise<string>;

    downVotes(overrides?: CallOverrides): Promise<BigNumber>;

    "downVotes()"(overrides?: CallOverrides): Promise<BigNumber>;

    downvote(overrides?: CallOverrides): Promise<void>;

    "downvote()"(overrides?: CallOverrides): Promise<void>;

    /**
     * this function is used by manager to load correct answer
     * @param _choice is the correct choice
     */
    endBet(_choice: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * this function is used by manager to load correct answer
     * @param _choice is the correct choice
     */
    "endBet(uint8)"(
      _choice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    endTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    "endTimestamp()"(overrides?: CallOverrides): Promise<BigNumber>;

    endedBy(overrides?: CallOverrides): Promise<string>;

    "endedBy()"(overrides?: CallOverrides): Promise<string>;

    /**
     * this function is used to place a bet on available choice
     * @param _betTokensInExaEs is amount of bet
     * @param _choice should be 0, 1, 2; no => 0, yes => 1, draw => 2
     */
    enterBet(
      _choice: BigNumberish,
      _betTokensInExaEs: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * this function is used to place a bet on available choice
     * @param _betTokensInExaEs is amount of bet
     * @param _choice should be 0, 1, 2; no => 0, yes => 1, draw => 2
     */
    "enterBet(uint8,uint256)"(
      _choice: BigNumberish,
      _betTokensInExaEs: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    finalResult(overrides?: CallOverrides): Promise<number>;

    "finalResult()"(overrides?: CallOverrides): Promise<number>;

    getNumberOfChoiceBettors(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getNumberOfChoiceBettors(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * this sets up Bet contract
     * @param _category is the broad category for example Sports. Purpose of this is only to filter bets and show in UI, hence the name of the category is not stored in smart contract and category is repressented by a number (0, 1, 2, 3...)
     * @param _description is the question of Bet in plain English, bettors have to understand the bet description and later choose to bet on yes no or draw according to their preference
     * @param _isDrawPossible is functionality for allowing a draw option
     * @param _minimumBetInExaEs is the least amount of ExaES that can be betted, any bet participant (bettor) will have to bet this amount or higher. Betting higher amount gives more share of winning amount
     * @param _pauseTimestamp Bet will be open for betting until this timestamp, after this timestamp, any user will not be able to place bet. and manager can only end bet after this time
     * @param _prizePercentPerThousand is a form of representation of platform fee. It is a number less than or equal to 1000. For eg 2% is to be collected as platform fee then this value would be 980. If 0.2% then 998.
     * @param _subCategory is a specific category for example Football. Each category will have sub categories represented by a number (0, 1, 2, 3...)
     */
    initialize(
      _owner1: string,
      _description: string,
      _category: BigNumberish,
      _subCategory: BigNumberish,
      _minimumBetInExaEs: BigNumberish,
      _prizePercentPerThousand: BigNumberish,
      _isDrawPossible: boolean,
      _pauseTimestamp: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * this sets up Bet contract
     * @param _category is the broad category for example Sports. Purpose of this is only to filter bets and show in UI, hence the name of the category is not stored in smart contract and category is repressented by a number (0, 1, 2, 3...)
     * @param _description is the question of Bet in plain English, bettors have to understand the bet description and later choose to bet on yes no or draw according to their preference
     * @param _isDrawPossible is functionality for allowing a draw option
     * @param _minimumBetInExaEs is the least amount of ExaES that can be betted, any bet participant (bettor) will have to bet this amount or higher. Betting higher amount gives more share of winning amount
     * @param _pauseTimestamp Bet will be open for betting until this timestamp, after this timestamp, any user will not be able to place bet. and manager can only end bet after this time
     * @param _prizePercentPerThousand is a form of representation of platform fee. It is a number less than or equal to 1000. For eg 2% is to be collected as platform fee then this value would be 980. If 0.2% then 998.
     * @param _subCategory is a specific category for example Football. Each category will have sub categories represented by a number (0, 1, 2, 3...)
     */
    "initialize(address,string,uint8,uint8,uint256,uint256,bool,uint256)"(
      _owner1: string,
      _description: string,
      _category: BigNumberish,
      _subCategory: BigNumberish,
      _minimumBetInExaEs: BigNumberish,
      _prizePercentPerThousand: BigNumberish,
      _isDrawPossible: boolean,
      _pauseTimestamp: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    isBetValid(arg0: string, overrides?: CallOverrides): Promise<boolean>;

    "isBetValid(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isDrawPossible(overrides?: CallOverrides): Promise<boolean>;

    "isDrawPossible()"(overrides?: CallOverrides): Promise<boolean>;

    minimumBetInExaEs(overrides?: CallOverrides): Promise<BigNumber>;

    "minimumBetInExaEs()"(overrides?: CallOverrides): Promise<BigNumber>;

    pauseTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    "pauseTimestamp()"(overrides?: CallOverrides): Promise<BigNumber>;

    prizePercentPerThousand(overrides?: CallOverrides): Promise<BigNumber>;

    "prizePercentPerThousand()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * this function can be called by anyone to see how much winners are getting
     * @param _bettorAddress is address whose prize we want to see
     */
    seeWinnerPrize(
      _bettorAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * this function can be called by anyone to see how much winners are getting
     * @param _bettorAddress is address whose prize we want to see
     */
    "seeWinnerPrize(address)"(
      _bettorAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setKYC(user: string, overrides?: CallOverrides): Promise<void>;

    "setKYC(address)"(user: string, overrides?: CallOverrides): Promise<void>;

    subCategory(overrides?: CallOverrides): Promise<number>;

    "subCategory()"(overrides?: CallOverrides): Promise<number>;

    totalBetTokensInExaEsByChoice(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "totalBetTokensInExaEsByChoice(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * this function gives amount of ExaEs that is total betted on this bet
     */
    totalContractBalance(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * this function gives amount of ExaEs that is total betted on this bet
     */
    "totalContractBalance()"(overrides?: CallOverrides): Promise<BigNumber>;

    totalPrize(overrides?: CallOverrides): Promise<BigNumber>;

    "totalPrize()"(overrides?: CallOverrides): Promise<BigNumber>;

    upVotes(overrides?: CallOverrides): Promise<BigNumber>;

    "upVotes()"(overrides?: CallOverrides): Promise<BigNumber>;

    upvote(overrides?: CallOverrides): Promise<void>;

    "upvote()"(overrides?: CallOverrides): Promise<void>;

    /**
     * this function will be called after bet ends and winner bettors can withdraw their prize share
     */
    withdrawPrize(
      _bettorAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * this function will be called after bet ends and winner bettors can withdraw their prize share
     */
    "withdrawPrize(address)"(
      _bettorAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    EndBetContract(
      _ender: string | null,
      _contractAddress: string | null,
      _result: null,
      _platformFee: null
    ): EventFilter;

    NewBetting(
      _betAddress: string | null,
      _bettorAddress: string | null,
      _choice: BigNumberish | null,
      _betTokensInExaEs: null
    ): EventFilter;

    TransferES(_to: string | null, _tokensInExaEs: null): EventFilter;
  };

  estimateGas: {
    KYC(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    "KYC(address)"(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    betBalanceInExaEs(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "betBalanceInExaEs(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    bettorBetAmountInExaEsByChoice(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "bettorBetAmountInExaEsByChoice(address,uint256)"(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    bettorHasClaimed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "bettorHasClaimed(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    category(overrides?: CallOverrides): Promise<BigNumber>;

    "category()"(overrides?: CallOverrides): Promise<BigNumber>;

    description(overrides?: CallOverrides): Promise<BigNumber>;

    "description()"(overrides?: CallOverrides): Promise<BigNumber>;

    downVotes(overrides?: CallOverrides): Promise<BigNumber>;

    "downVotes()"(overrides?: CallOverrides): Promise<BigNumber>;

    downvote(overrides?: Overrides): Promise<BigNumber>;

    "downvote()"(overrides?: Overrides): Promise<BigNumber>;

    /**
     * this function is used by manager to load correct answer
     * @param _choice is the correct choice
     */
    endBet(_choice: BigNumberish, overrides?: Overrides): Promise<BigNumber>;

    /**
     * this function is used by manager to load correct answer
     * @param _choice is the correct choice
     */
    "endBet(uint8)"(
      _choice: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    endTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    "endTimestamp()"(overrides?: CallOverrides): Promise<BigNumber>;

    endedBy(overrides?: CallOverrides): Promise<BigNumber>;

    "endedBy()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * this function is used to place a bet on available choice
     * @param _betTokensInExaEs is amount of bet
     * @param _choice should be 0, 1, 2; no => 0, yes => 1, draw => 2
     */
    enterBet(
      _choice: BigNumberish,
      _betTokensInExaEs: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    /**
     * this function is used to place a bet on available choice
     * @param _betTokensInExaEs is amount of bet
     * @param _choice should be 0, 1, 2; no => 0, yes => 1, draw => 2
     */
    "enterBet(uint8,uint256)"(
      _choice: BigNumberish,
      _betTokensInExaEs: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    finalResult(overrides?: CallOverrides): Promise<BigNumber>;

    "finalResult()"(overrides?: CallOverrides): Promise<BigNumber>;

    getNumberOfChoiceBettors(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getNumberOfChoiceBettors(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * this sets up Bet contract
     * @param _category is the broad category for example Sports. Purpose of this is only to filter bets and show in UI, hence the name of the category is not stored in smart contract and category is repressented by a number (0, 1, 2, 3...)
     * @param _description is the question of Bet in plain English, bettors have to understand the bet description and later choose to bet on yes no or draw according to their preference
     * @param _isDrawPossible is functionality for allowing a draw option
     * @param _minimumBetInExaEs is the least amount of ExaES that can be betted, any bet participant (bettor) will have to bet this amount or higher. Betting higher amount gives more share of winning amount
     * @param _pauseTimestamp Bet will be open for betting until this timestamp, after this timestamp, any user will not be able to place bet. and manager can only end bet after this time
     * @param _prizePercentPerThousand is a form of representation of platform fee. It is a number less than or equal to 1000. For eg 2% is to be collected as platform fee then this value would be 980. If 0.2% then 998.
     * @param _subCategory is a specific category for example Football. Each category will have sub categories represented by a number (0, 1, 2, 3...)
     */
    initialize(
      _owner1: string,
      _description: string,
      _category: BigNumberish,
      _subCategory: BigNumberish,
      _minimumBetInExaEs: BigNumberish,
      _prizePercentPerThousand: BigNumberish,
      _isDrawPossible: boolean,
      _pauseTimestamp: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * this sets up Bet contract
     * @param _category is the broad category for example Sports. Purpose of this is only to filter bets and show in UI, hence the name of the category is not stored in smart contract and category is repressented by a number (0, 1, 2, 3...)
     * @param _description is the question of Bet in plain English, bettors have to understand the bet description and later choose to bet on yes no or draw according to their preference
     * @param _isDrawPossible is functionality for allowing a draw option
     * @param _minimumBetInExaEs is the least amount of ExaES that can be betted, any bet participant (bettor) will have to bet this amount or higher. Betting higher amount gives more share of winning amount
     * @param _pauseTimestamp Bet will be open for betting until this timestamp, after this timestamp, any user will not be able to place bet. and manager can only end bet after this time
     * @param _prizePercentPerThousand is a form of representation of platform fee. It is a number less than or equal to 1000. For eg 2% is to be collected as platform fee then this value would be 980. If 0.2% then 998.
     * @param _subCategory is a specific category for example Football. Each category will have sub categories represented by a number (0, 1, 2, 3...)
     */
    "initialize(address,string,uint8,uint8,uint256,uint256,bool,uint256)"(
      _owner1: string,
      _description: string,
      _category: BigNumberish,
      _subCategory: BigNumberish,
      _minimumBetInExaEs: BigNumberish,
      _prizePercentPerThousand: BigNumberish,
      _isDrawPossible: boolean,
      _pauseTimestamp: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    isBetValid(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    "isBetValid(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isDrawPossible(overrides?: CallOverrides): Promise<BigNumber>;

    "isDrawPossible()"(overrides?: CallOverrides): Promise<BigNumber>;

    minimumBetInExaEs(overrides?: CallOverrides): Promise<BigNumber>;

    "minimumBetInExaEs()"(overrides?: CallOverrides): Promise<BigNumber>;

    pauseTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    "pauseTimestamp()"(overrides?: CallOverrides): Promise<BigNumber>;

    prizePercentPerThousand(overrides?: CallOverrides): Promise<BigNumber>;

    "prizePercentPerThousand()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * this function can be called by anyone to see how much winners are getting
     * @param _bettorAddress is address whose prize we want to see
     */
    seeWinnerPrize(
      _bettorAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * this function can be called by anyone to see how much winners are getting
     * @param _bettorAddress is address whose prize we want to see
     */
    "seeWinnerPrize(address)"(
      _bettorAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setKYC(user: string, overrides?: Overrides): Promise<BigNumber>;

    "setKYC(address)"(user: string, overrides?: Overrides): Promise<BigNumber>;

    subCategory(overrides?: CallOverrides): Promise<BigNumber>;

    "subCategory()"(overrides?: CallOverrides): Promise<BigNumber>;

    totalBetTokensInExaEsByChoice(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "totalBetTokensInExaEsByChoice(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * this function gives amount of ExaEs that is total betted on this bet
     */
    totalContractBalance(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * this function gives amount of ExaEs that is total betted on this bet
     */
    "totalContractBalance()"(overrides?: CallOverrides): Promise<BigNumber>;

    totalPrize(overrides?: CallOverrides): Promise<BigNumber>;

    "totalPrize()"(overrides?: CallOverrides): Promise<BigNumber>;

    upVotes(overrides?: CallOverrides): Promise<BigNumber>;

    "upVotes()"(overrides?: CallOverrides): Promise<BigNumber>;

    upvote(overrides?: Overrides): Promise<BigNumber>;

    "upvote()"(overrides?: Overrides): Promise<BigNumber>;

    /**
     * this function will be called after bet ends and winner bettors can withdraw their prize share
     */
    withdrawPrize(
      _bettorAddress: string,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    /**
     * this function will be called after bet ends and winner bettors can withdraw their prize share
     */
    "withdrawPrize(address)"(
      _bettorAddress: string,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    KYC(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "KYC(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    betBalanceInExaEs(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "betBalanceInExaEs(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    bettorBetAmountInExaEsByChoice(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "bettorBetAmountInExaEsByChoice(address,uint256)"(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    bettorHasClaimed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "bettorHasClaimed(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    category(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "category()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    description(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "description()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    downVotes(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "downVotes()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    downvote(overrides?: Overrides): Promise<PopulatedTransaction>;

    "downvote()"(overrides?: Overrides): Promise<PopulatedTransaction>;

    /**
     * this function is used by manager to load correct answer
     * @param _choice is the correct choice
     */
    endBet(
      _choice: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * this function is used by manager to load correct answer
     * @param _choice is the correct choice
     */
    "endBet(uint8)"(
      _choice: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    endTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "endTimestamp()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    endedBy(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "endedBy()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * this function is used to place a bet on available choice
     * @param _betTokensInExaEs is amount of bet
     * @param _choice should be 0, 1, 2; no => 0, yes => 1, draw => 2
     */
    enterBet(
      _choice: BigNumberish,
      _betTokensInExaEs: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * this function is used to place a bet on available choice
     * @param _betTokensInExaEs is amount of bet
     * @param _choice should be 0, 1, 2; no => 0, yes => 1, draw => 2
     */
    "enterBet(uint8,uint256)"(
      _choice: BigNumberish,
      _betTokensInExaEs: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    finalResult(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "finalResult()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getNumberOfChoiceBettors(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getNumberOfChoiceBettors(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * this sets up Bet contract
     * @param _category is the broad category for example Sports. Purpose of this is only to filter bets and show in UI, hence the name of the category is not stored in smart contract and category is repressented by a number (0, 1, 2, 3...)
     * @param _description is the question of Bet in plain English, bettors have to understand the bet description and later choose to bet on yes no or draw according to their preference
     * @param _isDrawPossible is functionality for allowing a draw option
     * @param _minimumBetInExaEs is the least amount of ExaES that can be betted, any bet participant (bettor) will have to bet this amount or higher. Betting higher amount gives more share of winning amount
     * @param _pauseTimestamp Bet will be open for betting until this timestamp, after this timestamp, any user will not be able to place bet. and manager can only end bet after this time
     * @param _prizePercentPerThousand is a form of representation of platform fee. It is a number less than or equal to 1000. For eg 2% is to be collected as platform fee then this value would be 980. If 0.2% then 998.
     * @param _subCategory is a specific category for example Football. Each category will have sub categories represented by a number (0, 1, 2, 3...)
     */
    initialize(
      _owner1: string,
      _description: string,
      _category: BigNumberish,
      _subCategory: BigNumberish,
      _minimumBetInExaEs: BigNumberish,
      _prizePercentPerThousand: BigNumberish,
      _isDrawPossible: boolean,
      _pauseTimestamp: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * this sets up Bet contract
     * @param _category is the broad category for example Sports. Purpose of this is only to filter bets and show in UI, hence the name of the category is not stored in smart contract and category is repressented by a number (0, 1, 2, 3...)
     * @param _description is the question of Bet in plain English, bettors have to understand the bet description and later choose to bet on yes no or draw according to their preference
     * @param _isDrawPossible is functionality for allowing a draw option
     * @param _minimumBetInExaEs is the least amount of ExaES that can be betted, any bet participant (bettor) will have to bet this amount or higher. Betting higher amount gives more share of winning amount
     * @param _pauseTimestamp Bet will be open for betting until this timestamp, after this timestamp, any user will not be able to place bet. and manager can only end bet after this time
     * @param _prizePercentPerThousand is a form of representation of platform fee. It is a number less than or equal to 1000. For eg 2% is to be collected as platform fee then this value would be 980. If 0.2% then 998.
     * @param _subCategory is a specific category for example Football. Each category will have sub categories represented by a number (0, 1, 2, 3...)
     */
    "initialize(address,string,uint8,uint8,uint256,uint256,bool,uint256)"(
      _owner1: string,
      _description: string,
      _category: BigNumberish,
      _subCategory: BigNumberish,
      _minimumBetInExaEs: BigNumberish,
      _prizePercentPerThousand: BigNumberish,
      _isDrawPossible: boolean,
      _pauseTimestamp: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    isBetValid(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isBetValid(address)"(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isDrawPossible(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "isDrawPossible()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    minimumBetInExaEs(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "minimumBetInExaEs()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    pauseTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "pauseTimestamp()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    prizePercentPerThousand(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "prizePercentPerThousand()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * this function can be called by anyone to see how much winners are getting
     * @param _bettorAddress is address whose prize we want to see
     */
    seeWinnerPrize(
      _bettorAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * this function can be called by anyone to see how much winners are getting
     * @param _bettorAddress is address whose prize we want to see
     */
    "seeWinnerPrize(address)"(
      _bettorAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setKYC(user: string, overrides?: Overrides): Promise<PopulatedTransaction>;

    "setKYC(address)"(
      user: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    subCategory(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "subCategory()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalBetTokensInExaEsByChoice(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "totalBetTokensInExaEsByChoice(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * this function gives amount of ExaEs that is total betted on this bet
     */
    totalContractBalance(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * this function gives amount of ExaEs that is total betted on this bet
     */
    "totalContractBalance()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalPrize(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "totalPrize()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    upVotes(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "upVotes()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    upvote(overrides?: Overrides): Promise<PopulatedTransaction>;

    "upvote()"(overrides?: Overrides): Promise<PopulatedTransaction>;

    /**
     * this function will be called after bet ends and winner bettors can withdraw their prize share
     */
    withdrawPrize(
      _bettorAddress: string,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * this function will be called after bet ends and winner bettors can withdraw their prize share
     */
    "withdrawPrize(address)"(
      _bettorAddress: string,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;
  };
}
